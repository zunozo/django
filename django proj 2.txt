Using models

장고 웹 어플리케이션들은 모델이라는 파이썬 객체를 통해 데이터에 접속하고 관리함. 모델은 저장된 데이터의 구조를 정의함. 그것엔 필드 타입, 그리고 데이터의 최대 크기, 기본 값, 선택 리스트 옵션, 몬서를 위한 도움 텍스트, 폼을 위한 라벨 텍스트 등등이 있음. 모델의 정의는 기초 db에 대해 독립적임.(프로젝트 설정의 일부로 여러 옵션 중 하나를 선택할 수 있음. 사용할 데이터베이스를 정했다면 데이터베이스에 직접적으로 말할 필요가 없음) 그저 모델 구조와 기타코드를 작성하면, 장고가 데이터베이스와 소통하는 모든 더러운 작업을 대신해줌.

1. locallibrary models 디자인하기
모델을 코딩하기 전에, 우리가 어떤 데이터를 저장할 것인지, 그리고 다른 객체들에 대한 관계를 어떻게 지정할 것인지 생각.
우리는 책에 관한 정보들을 저장할 필요가 있고(제목, 요약, 저자, 작성된 언어, 분류, ISBN) 여러 개의 사본을 사용할 수 있어야 함.(전 세계적으로 고유한 ID, 가용성 상태 등). 저자에 대해 그들의 이름 뿐만 아니라 더 많은 정보를 저장해야 할 수도 있음. 여러 명의 같거나 비슷한 이름의 저자가 있을 수도 있기 떄문. 우리는 정보를 책 제목, 저자, 언어, 그리고 분류에 따라 정렬할 수 있기를 원함.

모델을 디자인할 때는 각각의 "객체(object: 관련된 정보의 모임)"마다 분리된 모델을 가지는 것이 타당함. 이 예시에서 명백히 확인할 수 있는 객체들은 책, 책인스턴스, 저자임.

선택을 웹사이트 자체에 하드코딩하는 것 보다는 모델을 사용해서 선택-리스트 옵션을 나타내도록(예시:드롭 다운 목록)할 수 있음. 이것은 모든옵션들을 미리 알 수 없거나 옵션들이 변할 수 있을 때에 추천됨. 이 경우에 명백한 모델의 후보자로 책의 장르와 언어가 있음.

우리가 우리의 모델과 필드를 결정하고 나면, 우리는 그 관계에 대해서 생각해야 함. 장고는 당신이 그 관계를 다음과 같이 세 가지로 설정할 수 있게 하는데, 일대일, 일대다, 다대다 관계가 있음.

그것들을 염두에 두고 아래의 UML 관계 다이어그램을 살펴보자. 이 다이어그램은 우리가 이 예시에서 정의할 모델들을 상자로 보여줌. 위에서 살펴본 바와 같이, 우리는 책, 책 인스턴스, 그리고 저자를 모델로 생성했음. 우리는 또한 장르에 대한 모델을 만들어서 값들이 관리자 인터페이스에서 생성/선택이 가능하도록 만들었음. 우리는 bookinstance:status 에 대한 모델을 생성하지 않았음. 값들을 하드코딩함. 왜냐하면 그것은 변하지 않는 값들이기 때문. 각각의 상자 안에서 모델 이름, 필드 이름과 타입, 그리고 또한 함수와 그들의 반환 타입을 확인할 수 있음.

다중도는 관계 안에 존재하는 각가의 모델의 숫자를 보여주는 다이어그램 위의 숫자임. 예를들어 상자 사이를 연결하는 선은 책과 장르가 연관되어 있다는 것을 보여줌. 장르 모델에 가까이 있는 숫자들은 책이 하나 또는 그 이상의 장르를 가지고 있어야 함을 보여주는 반면, 선의 반대편 끝에 있는 책 모델 옆의 숫자들은 장르 모델이 0또는 여러개의 관련된 책 모델을 가질 수 있음을 보여줌.

2. 모델의 정의
모델들은 보통 어플리케이션의 models.py 파일에서 정의됨. 이들은 django.db.models.Model의 서브 클래스로 구현되며 필드, 메소드 그리고 메타데이터를 포함할 수 있음. 아래의 코드 조각은 MyModelName라고 이름지어진 "전형적인"모델을 보여줌.

필드(Fields)
모델은 모든 타입의, 임의의 숫자의 필드를 가질 수 있음.각각의 필드는 우리의 데이터베이스 목록에 저장하길 원하는 데이터 열을 나타냄. 각각의 데이터베이스 레코드(행,row)는 각 필드 값들 중 하나로 구성되어 있음.
ex)
my_filed_name = models.CharField(max_length=20, help_text='Enter field documentation')
위 예제는 my_field_name이라는 하나의 필드를 가지고 있고, models.CharField 타입임.(즉 이 필드가 영숫자 문자열을 포함한다는 뜻) 필드 타입들은 특정한 클래스들을 사용하여 등록되며, HTML 양식(form)에서 값을 수신할 때 사용할 유효성 검증 기준과 함께 데이터베이스에 데이터를 저장하는데 사용되는 레코드의 타입을 결정함. 또한 필드 타입은 필드가 어떻게 저장되고 사용될지 지정하는 인수를 사용할 수 있음.
max_length = 20 이 필드값의 최대길이는 20자임을 알림
help_text='~~~' 이 값이 HTML 양식에서 사용자들에게 입력될 때 어떤 값을 입력해야 하는지 사용자들에게 알려주기 위해 보여주는 텍스트 라벨을 제공함.
필드이름은 쿼리 및 탬플릿에서 이를 참조하는데 쓰임. 필드는 또한 인수로 지정된 라벨(verbose_name)을 가지고 있거나, 또는 필드 변수 이름의 첫자를 대문자로 바꾸고 밑줄을 공백으로 바꿔서 기본 라벨을 추정할 수 있음(my_field_name -> My field name)
필드가 선언된 순서는 모델이 폼에서 렌더링 된다면 기본 순서에 영향을 미치지만, 이것은 재정렬될 수 있음.
일반적 필드 인수
help_text : html 양식에 대해 텍스트라벨을 제공함
verbose_name : 필드 라벨 안에서 사용되는 인간이 읽을 수 있는 필드 이름임. 지정되지 않았다면, 장고가 기본 verbose_name을 필드 이름으로부터 유추함.
default : 필드를 위한 기본값. 이것은 값 또는 호출 가능한 객체일 수 있음. 이때 객체는 새로운 레코드가 생성될 때 마다 호출됨.
null : 만약 True라면, 장고는 빈 NULL값을 필드를 위한 데이터베이스에 저장할 것임.(CharField는 대신 빈 문자열을 저장할 것임.)기본값은 False.
blank : 만약 True라면, 필드는 양식(form)안에서 비워두는 것이 허락됨. 기본값은 False이며, 이것은 장고의 양식 검증이 값을 입력하도록 강제한다는 뜻임. 이것은 종종 null=True와 함께 사용됨. blank 값을 허락할 때, DB에서도 공백값을 적절하게 표시할 수 있어야 하기 때문.
choices : 필드를 위한 선택들의 모임. 이 인수가 제공된다면, 대응하는 기본 양식 위젯은 표준 텍스트 필드가 아닌 이 선택 항목을 가진 선택 상자임.
primary_key : 만약 True라면, 현재 필드를 모델의 primary key로 설정함.(primary key는 모든 다른 테이블 레코드들을 고유하게 확인하도록 지정된 특별한 데이터베이스 열임.) primary key 로 지정된 필드가 없다면 장고가 자동적으로 이 목적의 필드를 추가함.

일반적인 필드 타입
CharField : 작거나 중간 크기의 고정된 길이의 문자열을 정의할 때 사용함. 저장되기 위해서는 데이터의 최대 길이(max_length)를 정해주어야 함.
TextField는 임의의 긴 문자열에 사용됨. 필드의 최대 길이를 지정해야 할 수도 있지만, 그것은 필드가 양식안에 표시될 때만 지정하면 됨.(db레벨에서 강제되지 않음)
IntegerField : 정수값을 저장하는 필드. 그리고 양식에 입력된 값이 정수임을 검증하기도 함.
DataField와 DataTimeField는 날짜와 날짜 시간 정보를 저장, 표현하는데 사용됨.(각각 파이썬 datatime.date와 datetime.datetime 객체로). 이 필드들은 추가적으로 auto_now = True(모델이 저장될 때마다 필드를 현재 날짜로 설정하기 위해), auto_now_add(모델이 처음 생성되엇을 때만 날짜를 설정하기 위해), 그리고 default(사용제의해 변경될 수 있는 기본 날짜를 설정하기 위해) 매개 변수를 선언할 수 있음.
EmailField는 이메일 주소를 저장하고 검증하기 위해 사용.
FileField와 ImageField : 각각 파일과 이미지를 업로드 하기 위해 사용됨.(imageField는 단지 업로드된 파일이 이미지임을 확인하는 추가 검증을 더한 뿐임) 이것들은 업로드된 파일들이 어디에 어떻게 저장되는지 정의하는 매개 변수를 가짐.
AutoField는 자동적으로 증가하는 IntegerField의 특별한 타입임. 이 타입의 primary key는 명시적으로 지정하지 않는 이상 모델에 자동적으로 추가됨.
ForeignKey는 다른 db모델과 일대다 관계를 지정하기 위해 사용됨. 일대다에서 "일"쪽이 key를 포함하는 모델임.
manytomanyField는 다대다 관계를 지정하기 위해 사용됨. 도서관 어플리케이션에서는 이 필드를 ForeignKeys와 매우 유사하게 사용함. 하지만 그룹 사이의 관계를 보여주기 위해서는 더욱 복잡한 방식으로 사용될 수 있음. 이것은 레코드가 삭제 됐을 때 어떤일이 일어나는지 정의하기 위해 on_delete 매개 변수를 가짐.

3. 메타데이터
Class Meta를 선언하여 모델에 대한 모델-레벨의 메타데이터를 선언할 수 있음.
class Meta:
	ordering = ['-my_field_name']
이 메타데이터의 가장 유용한 기능들 중 하나는 모델 타입을 쿼리할 때 반환되는 기본 레코드 순서를 제어하는 것임. 이렇게 하려면 위와 같이 필드 이름목록의 일치순서를 ordering 속성에 지정해야 함. 순서는 필드의 타입에 따라 달라짐.(문자 필드는 알파벳 순서에 따라 정렬될 것이고, 반면 날짜 필드는 날짜순으로 정렬됨). 반대로 정렬하고 싶다면 마이너스 기호를 필드 이름 앞에 접두사로 붙이면 됨.

다른 일반적인 속성은 verbose_name이며, 단일 및 복수형식의 클래스를 위한 자세힌 이름임.
다른 유용한 속성들은 모델을 새로운 접근 권한을 생성 및 적용 가능하게 하며(기본 권한은 자동적으로 적용됨), 다른 필드에 기반한 순서 정렬을 허용하거나, 또는 클래스가 "추상(abstract: 레코드를 생성할 수 없고, 대신 다른 모델들을 만들기 위해 파생되는 기본 클래스)"임을 선언할 수 있음.

여러가지 메타데이터 옵션들은 모델에 무슨 데이터베이스를 사용해야만 하는가 그리고 데이터가 어떻게 저장되는가 를 제어한다.(이것들은 모델을 기존 db에 매핑할 때만 유용함)

4. 메소드(Methods)
모델은 또한 메소드를 가질 수 있음.
최소한, 모든 모델마다 표준 파이썬 클래스의 메소드인 __str__()을 정의하여 각각의 object가 사람이 읽을 수 있는 문자열을 반환하도록 함. 이 문자열은 관리자 사이트에 있는 개별적인 레코드들을 보여주는 데 사용됨.(그리고 모델 인스턴스를 참조해야 하는 다른 모든 곳에서도.) 종종 이것은 모델에서 제목(title)이나 이름 필드(name field)를 반환할 것임.

self.field_name

장고 모델에 포함할 다른 일반적인 메소드는 get_absolute url()임. 웹사이트의 개별적인 모델 레코드들을 보여주기 위한 URL을 반환하는 메소드임.(만약 이 메소드를 정의 했다면 장고는 관리자 사이트 안의 모델 레코드 수정 화면에 "view on site"버튼을 자동적으로 추가할 것임.)아래에서 get_absolute_url()의 표준적인 사용을 볼 수 있음.

reverse('model-detail-view', args=[str(self.id)])
모델의 개별적인 레코드들을 보여주기 위해서 /myapplication/mymodelname/2 와 같은 URL을 사용한다고 가정하면 응답과 id를 "모델 디테일 뷰"에 전달하기 위해 (레코드를 표시하기 위한 작업을 할) URL 매퍼를 만들 필요가 있음. 위의 reverse() 함수는 알맞은 포맷의 URL을 생성하기 위해서 URL 매퍼를 (위 경우에선 'model-detail-view'라고 명명됨)"반전"시킬 수 있음.
물론 이것이 작동하기 위해선 URL 매핑, 뷰, 그리고 템플릿을 작성해야 함.

또한 원하는 메소드를 정의해서 (그들이 어떤 변수도 가지고 있지 않다면)코드나 탬플릿에ㅓㅅ 불러올 수 있음.

5. 모델 관리
모델 클래스들을 정의한 이후엔 클래스들을 사용해서 레코드들을 생성, 업데이트, 또는 삭제 할 수 있고, 모든 레코드 또는 레코드의 특정 하위 집합을 가져오기 위해 쿼리를 실행할 수 있음.

5-1. 레코드의 생성과 수정
레코드를 생성하려면 모델의인스턴스를 정의하고 save()를 호출할 수 있음.
만약 당신이 어떤 필드도 primary_key 를 선언하지 않았다면, 새로운 레코드는 자동적으로 id라는 필드 이름을 가진 primary_key가 주어지게 됨. 위의 레코드를 저장한 후 이 id 필드를 쿼리할 수 있는데, 1의 값을 가질것임.

이 새로운 레코드안의 필드에 점 구문(.)을 사용해서 접근하여 값을 변경할 수 있음. 수정된 값들을 데이터베이스 저장하기위해 save()를 호출해야 함.

5-2. 레코드 검색하기
모델의 객체 속성을 사용하여 특정 기준과 일치하는 레코드를 검색할 수 있음.
추상(abstract) 모델과 필드 이름을 사용하여 레코드들을 검색하는 방법을 설명하는 것은 조금 혼란스얼수 있음. 아래에서는 title과 genre 필드가 있는 Book 모델을 참조하겠음. 이 때 genre는 또한 name이라는 단일 필드를 가지고 있는 모델임.
우리는 objects.all()을 사용하여 모델의 모든 레코드들을 QuerySet으로 가져올 수 있음. QuerySet은 반복가능한(iterable)객체이며, 익서은 반복/루프할 수 있는 많은 객체들을 포함 하고 있다는 의미임.

장고의 filter()는 반환된 QuerySet이 지정된 문자(text) 또는 숫자필드를 특정한 기준에 맞추어 필터링 할 수 있게 함. 예를 들어서, "wild"를 제목 안에 포함하는 책들을 필터링하여 그 숫자를 세어보려면, 아래와 같이 하면됨.
wilds_books=Books.ojbects.filter(title_contains='wild')
number_wild_books = Book.objects.filter(title__contains='wild').count()

기준이 될 필드와 타입은 필터 매개 변수 이름에서 정의됨. 다음 포맷을 이용해서:field_name__match_type
위에서 우리는 대소문자를 구분하여 title을 필터링합니다. 다른 많은 유형의 일치방법이 있습니다. icontains(대소문자를 구분하지 않음), iexact(대소문자를 구분하지 않는 정확히 일치), exact(대소문자를 구분하는 정확한 일치) 그리고 in, gt, startswith 등등이 있음.
어떤 경우엔 일대다 관계를 다른 모델에 정의하는 필드를 필터링해야 할 때도 있음.(ForeignKey) 이 경우에 추가적인 이중 밑줄을 사용하여 관련 모델 안의 필드에 "색인(index)"할 수 있음. 예를들어 특정한 장르 패턴을 가진 책들을 필터링하려면, 아래와 같이 genre 필드를 통해서 name 에 index해야 함.
books_contaning_genre = Book.objects.filter(genre__name__icontains='fiction')
밑줄(__)을 사용하여 원하는 만큼 다양한레벨의 관계(ForeignKey/ManytoManyField)를 탐색할 수 있음. 예를 들어서 추가적인 "cover"관계를 사용하여 정의된 다른 타입의 Book은 다음과 같은 매개 변수 이름을 가짐. : type__cover__name__exact='hard'

6. LocalLibrary 모델 정의하기
Genre 모델
모델은 하나의 charfield 필드(name)을 가지고 있음. 이것은 장르의 이름을 나타냄. 이것은 200자로 제한되어 있고 help_text를 갖고 있음. 모델의 마지막에서 우리는 __str__() 메소드를 선언함. 이 메소드는 특정한 레코드에 의해 정의된 장르의 이름을 단지 반환함. 아무런 자세한 이름(verbose name)도 정의되지 않았기 때문에, 필드는 폼에서 Name으로 호출될 것임.

Book 모델
모델은 CharField를 사용하여 책의 title과 isbn을 나타냄.
장르는 책이 여러개의 장르를 가지고, 장르도 여러 개의 책을 가질 수 있는 다대다 필드임. 저자는 ForeignKey로 선언됨. 따라서 각각의 책은 하나의 저자만 가질 수 있찌만, 저자는 여러 개의 책들을 가질 수 있음.(실제로는 책이 여러 명의 작가를 가질 수 있지만, 이 구현에서는 아님.)

두 필드 타입들 안에서 관련된 모델 클래스는 모델 클래스나 관련된 모델의 이름을 포함하는 문자열을 사용하여 일이름없는 첫 번째 매개 변수로 선언됨. 연관된 클래스가 참조되기 전에 파일 안에서 아직 정의되지 않았다면 모델의 이름을 문자열로 사용해야 함. 저자(author)필드 에서 관심을 가져야 할 다른 변수는 null=True와 on_delete=models.SET_NULL. null=True는 어떤 저자도 선택되지 않았다면 데이터베이스에 Null값을 저장하도록 하고, on_delte=models.SET_NULL은 관련된 저자(author)레코드가 삭제되었을 때 저자(author)의 값을 Null로 설정할 것임.

모델은 또한 Book 레코드를 나타내는 책의 title 필드를 사용하여 __str__()를 정의함. 마지막 메소드 get_absolute_url()은 이 모델의 세부 레코드에 접근하는 데에 사용될 수 있는 URL을 반환함.(이것이 작동하도록 하기 위해선 book-detail이라는 이름의 URL매핑을 정의하고, 관련 뷰와 템플릿을 정의해야 함)

BookInstance 모델
ForeignKey : 연관된 Book을 식별하기 위해(각각의 책은 많은 복사본을 가질 수 있지만, 복사본은 하나의 Book만을 가질 수 있음).
CharField : 책의 출판사(imprint)(특정한 발간일)을 나타내기 위해.

UUIDField 는 id 필드가 이 모델의 primary_key로 설정되는 데 사용됩니다. 이 타입의 필드는 각 인스턴스에 전역적으로 고유한 값을 할당합니다(도서관에서 찾을 수 있는 모든 책 마다 하나씩)
DateField 는 due_back (만기일) 날짜에 사용됩니다 (책이 빌려지거나 유지 보수된 이후 사용할 수 있을 것으로 예상되는 날짜). 이 값은 blank 나 null이 될 수 있습니다(책을 사용할 수 있는 경우 필요). 메타데이터 모델(Class Meta)은 레코드들이 쿼리에서 반환되었을 때 레코드들을 정렬하기 위해서 이 필드를 사용함.
status는 선택/선택 목록을 정의하는 charField. 보시다 시피, 우리는 열쇠-값(key-value)쌍에서 값(value)은 사용자가 선택할 수 있는 표시값인 반면, 열쇠(key)는 그 옵션이 선택되었을 때 실제로 저장되는 값입니다. 또한 책이 선반에 저장되기 전에는 사용할 수 없으므로 기본값인 'm'(유지 관리, maintenanace)을 설정했습니다.
모델 __str__() 은 그것의 고유한 id 그리고 연관된 Book의 제목을 조합하여 BookInstance 객체를 나타냄.

f-strings.
ex) f'hi my name is {name}' 하면 name에 변수였던 값이 출력되어서 나옴.
처음알았는데 문자출력하는데 굉장히 좋은옵션인듯

Author 모델
기본적으로 __str__()는 name을 첫째로 성, 그다음 이름이 오는 순서로 반환합니다.
get_absolute_url() 메소드는 개별 저자를 나타내기 위한 URL을 가져오기 위해 author-detail URL 매핑을 반대로 함.

추가.. Language를 어떻게 추가해야할까?
