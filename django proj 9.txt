Django 웹 어플리케이션 테스트

웹사이트가 성장함에 따라 손으로 일일히 테스트하는 것은 점점 더 어려워진다. 테스트 할 내용이 늘어날 뿐만 아니라, 컴포터는간의 상호작용도 복잡해지고, 한 쪽의 작은 수정이 다른쪽에 큰 영향을 줄 수 있기 때문에, 모든것이 잘 동작할 수 있도록 더 많은 수정이 필요해지며, 그렇게 추가된 수정이 새로운 에러를 유발하지 않도록 확인되어야 한다. 이러한 문제들의 해결책중 하나는, 쉽고 안정적으로 수정사항이 발생할 때마다 실행되는 자동화된 테스틀 작성하는 것이다. 이 튜토리얼은 Django의 test framework를 사용하여 당신의 웹 사이트에 대한 Unit Testing을 자동화하는 방법을 보여줄것이다.

Testing의 종류
테스트의 성격, 수준, 테스트의 종류 및 테스트에 대한 접근방법은 수없이 많다. 가장 중요한 방법들은 다음과 같다.
Unit test(유닛 테스트)
독립적인 컴포넌트의(성능이 아닌) 기능적인 동작을 검증한다. 흔히 Class나 Function 레벨로 수행한다.

Regression tests (버그수정 확인 테스트)
기존에 보고된 버그들이 재발하는지 테스트한다. 각 테스트는, 먼저 이전에 발생했던 버그가 수정되었는지 체크한 이후에, 버그 수정으로 인해 새롭게 발생되는 버그가 없는지 확인차 재수행하게 된다.

Integration tests (통합 테스트)
유닛 테스트를 완료한 각각의 독립적인 컴포터는들이 함께 결합되어 수행하는 동작을 검증한다. 통합 테스트는 컴포넌트간에 요구되는 상호작용을 검사하며, 각 컴포넌트의 내부적인 동작까지 검증할 필요는 없다. 이 테스트는 단지 전체 웹사이트에 걸쳐 각 컴포넌트가 결합하여 수행하는 동작을 대상으로 한다.

Django가 testing을 위해 제공하는 것은?
웹사이트를 테스트하는 것은 복잡한 작업임. 왜냐하면 이것이 HTTP 레벨의 리퀘스트 핸들링, 쿼리모델들, 폼 인증과 처리 그리고 템플릿 렌더링과 같은 여러 로직 레이어로 만들어졌기 때문.
Django 는 파이선 표준 라이브러리 unittest로 만들어진 작은 클라스계층의 테스트 프레임워크를 제공함. 그 이름과 다르게 이 테스트 프레임워크는 유닛테스트와 통합테스트 모두에게 적당함. 이 Django 프레임워크는 웹과 Django의 독특한 특징을 테스트하는 것을 돕기 위한 API메소드와 도구들을 추가함. 이것들은 당신이 리퀘스트를 시험하고, 시험 데이터를 삽입하고 그리고 당신의 어플리케이션의 결과물을 검사할 수 있게 함. Django는 또한 다른 테스트 프레임워크들을 사용하기 위한 APi와 도구들을 제공함. 예를 들어 당신은 사용자가 생중게 브라우저와 소통하는 것을 시뮬레이션하는 유명한 selenium 프레임워크와 통합할 수 있음.

테스트를 작성하기 위해서는 Django 테스트기반 클래스들로부터 어떤 것을 가져오고 그리고 그 다음에 특별한 기능이 기대했던대로 작동하는지 체크하기 위한 분리된 메소드들을 작성함. (테스트들은 그 표현식의 결과가 True 또는 False 값인지 또는 그 두값들이 동등한지 등을 테스트하기 위해 "assert"메소드를 사용함.) 당신이 테스트를 시작하면, 그 프레임워크는 당신의 가져온 클래스들안에서 선택된 테스트 메소드들을 실행함. 테스트 메소드들은 클라스에서 정의된 보통의 셋업 그리고/또는 tear-down 방식을 가지고 독립적으로 실행됨.

대부분의 테스트들을 위한 최선의 기본 클래스는 Django.test.TestCase임. 이 테스트 클래스는 이것이 실행되기 전에 하나의 깨끗한 db를 생성하고, 그리고 이 자체의 트랜젝션에서 모든 테스트를 실행함. 이 클래스는 자체의 테스트 클라이언트를 갖고있는데, 이것은 당신이 view 레벨에서 그 코드가 사용자와 상호작용하는 것을 시뮬레이션할 수 있게 함.
Django.test.TestCase는 매우 편리하지만, 어떤 테스트들은 그들이 필요로하는것보다 느려지는 결과가 올 수 있음.(모든 테스트들이 그들 자체의 db나 또는 view 상호작용의 셋업이 필요한 것은 아님) 한번 당신이 이클래스를 통해서 무엇을 할 수 있는지 익숙해진다면, 당신은 더 심플한 테스트 클래스들으륵 가지고 당신의 몇몇 테스트들을 대체하게 될 것임.

무엇을 테스트해야하는가?
Python 또는 Django의 일부분으로서 제공되는 라이브러리들 또는 기능들을 제외한 당신 코드의 모든 면을 테스트해야함.
그러나 당신은 그 레이블들 로 사용된 텍스트 그리고 그 텍스트들을 위해 할당한 그 필드의 크기를 확인해야 함. 왜냐하면 이것들은 당신이 디자인한 것 이고 추후에 깨지거나 변경될 수 잇는것이기 때문.
단순히 당신은 당신의 요구에 따라 만들어진 메소드들 get_absolute_url()과 __str__()이 원래 요구된 대로 작동하는지 체크해야함. 왜냐하면 이것들은 당신이 만들어낸 코드/비즈니스 로직이기 때문. get_absolute_url()의 경우에 있어서는 Django의 reverse()메소드는 적당하게 작동되었다고 신뢰할 수 있음. 그래서 당신이 테스트해야 하는 것은 시렞로 정의되어온 관련된 view임.
영리한 독자들은 date of birth와 date of death를 합리적인 값으로 제한해야 한다고 적어야 하고, 그리고 death는 birth보다 뒤에 왔는지를 체크해야 한다고 할 것임. Django에 있어서 이 제약은 당신의 폼클래스에 추가될 것임.(당신이 그필드들의 이러한 못브을 모델 레벨이 아니라 오직 폼 레벨에서 사용될 수 있도록 인증을 정의할 수 있다고 하질라도).

테스트 구조 개요
무엇을 테스트 할 지 자세히 보기 전에, 간단히 어디서 그리고 어떻게 테스트가 정의되는지 대략 살펴보자. 장고는 유닛테스트의 모듈인 bulit-in test discovery을 사용하는데, 이는 현재 작업중인 디렉토리의 test.py라는 패턴을 가진 모든 파일들을 체크함. 그 파일들의 이름을 적당하게 붙이는 한, 당신은 당신이 워하는 어떤 구조라도 이용할 수 있음. 우리는 당신의 테스트코드를 위한 한 모듈을 만들 것을 추천함. 그리고 모델들, 뷰들, 폼들 그리고 테스트가 필요한 어떤 다른 타입의 코드라도 각각을 분리하기를 바람.

당신은 종종 특정한 기능을 테스트하기 위한 개별적인 메소드들을 가지고 당신이 테스트하기를 원하는 각각의 모델/뷰/폼을 위한 테스트 클라스를 추가할 것임. 또 다른 경우에는 당신은 그 사용사례의 다방면을 테스트하기 위한 개별적인 테스트기능을 가지고, 특별한 사용사례를 테스트하기 위한 별도의 클라스를 갖기를 운할 것임. (예를 들면, 실패한 사례들을 테스트하는 기능을 가지고 모델 필드가 적정하게 인증되었는지 테스트하는 한 클라스) 다시한번, 그 구조는 오직 당신 자신에게 달렸음. 그러나 당신이 일관되게 하는 것이 최선의 방법임.

이 새로운 클래스는 테스트 전 준비를 위해 사용할 수 있는 메쏘드 두 개를 정의함.
setUpTestData()는 클래스 전체에서 사용되는 설정을 위해서 테스트 시작 때 딱 한 번만 실행됨. 테스트 메쏘드가 실행되면서 수정되거나 변경되지 않을 객체들을 이곳에서 생성할 수 있음.
setUp()은 각각의 테스트 메쏘드가 실행될 때마다 실행됨. 테스트 중 내용이 변경될 수 있는 객체를 이곳에서 생성할 수 있음. (모든 테스트 메쏘드는 방금 막 생성된 ('fresh')오브젝트를 입력받게 됨.)
테스트 클래스는 위 예제에서 사용하지 않은 teardown. 이 메소드는 특히 db테스트에는 유용하지가 않은데 바로 베이스 클래스인 TestCase가 데이터베이스 삭제를 처리해주기 때문.

우리는 위의 출력 결과를 통해서 객체와 메소드에 설명적인, 정보가 많은 이름을 ㅏㅅ용하는 것이 테스트 결과를 이해하는데 도움이 된다는 것을 배울 수 있음.

테스트에 대해 더 많은 정보를 출력하기.
테스트 실행에 대한 자세한 정보를 얻으려면 verbosity를 조절할 수 있음. 예를 들어 테스트 실패와 더불어 성공(그리고 테스트 db 생성 과정에 대한 정보)를 나열하려면 다음과 같이 verbosity를 "2"를 설정할 수 있음.

테스트의 일부만 실행하기
테스트 중 일부만 실행하려면 패키지, 모듈, Testcase 서브클래스, 메서드의 전체 경로를 지정해주면 됨.

LocalLibrary 테스트
1. 모델
위에서 논의했듯이 우리는 우리가 디자인 했거나,  우리가 작성한 코드의 동작만을 테스트해야하지 Djanog 또는 Python 개발팀에서 이미 테스트한 라이브러리/코드는 테스트하지 않아야함.
예를들어, Author모델을 보자면, 여기서 우리는 모든 필드의 라벨을 테스트해야 함. 우리가 필드의 라벨을 지정하지는 않았지만 우리의 디자인은 라벨의 값이어때야하는지를 이미정해놓고 잇기 때문임. 우리가 이값들을 테스트하지 안흔다면 필드 라벨에 의도된 값을 가지는지 알 수 없음, 마찬가지로 비록 우리는 Django가 필드들을 지정된 길이대로 만들 것이라고 믿지만, 그래도 필드의 길이를 테스트해보는 것이 헛되지는 않음.

몇가지 흥미로운 점들이 있는데, author.first_name.verbose_name 을 이용해서 verbose_name을 얻지 않음. 왜냐면 author.first_name은 문자열이지 우리가 속성에 접근할 수 있는 first_name 객체가 아니기 때문, 대신 우리는 author 객체의 _meta 속성을 이용해서 필드에 접근하여 필요한 정보를 어등ㅁ.
우리는 aseertTrue(field_label == 'first name' 대신 assertEquals(field_label,'first name')을 이용했음 왜냐면 만약 테스트가 실패할 경우 후자는 실제 라벨의 값을 알려주어 디버깅을 조금더 용이하게 만들어주기 때문.

우리는 우리가 작성한 메소드도 테스트를 해야 함. 객체의 이름이 우리가 예상한 대로 "last name", "First Name" 규칙에 맞게 생성되었는지와 Author 객체의 URL이 우리가 예상한 대로 생성되는지를 보면 됨.

2. Forms

Forms를 테스트하는 것은 모델을 테스트 하는 것과 비슷함. 당신이 만들고 디자인한 세세한 모든 것들은 테스트가 필요하며, 프레임워크나 third party library 등에 대해서는 테스트를 작성하지 않아도 좋음.
따라서 폼에 대한 테스트 코드를 작성할 떄는 보통 폼이 우리가 원하는 필드를 가지고 있는지, 그리고 이들 필드들이 적절한 라벨과 도움말과 함께 나타는지 테스트하면 됨. 직접 별도의 필들와 검증로직을 작성하지 않은 이상 장고가 필드 타입을 제대로 검증하는지는 테스트하지 않아도 됨. 예를 들어 이메일 필드가 정말로 이메일 주소 값만을 받아들이는지 직접 테스트할 필요가 없음. 하지만 필드에 대한 다른 추가적인 유효성 검증 로직과 달ㄴ 에러 메시지에 대해서는 테스트가 필요함.
책 정보를 갱신하기 위한 우리의 Form을 생각해보자. 이 Form은 갱신 날짜를 위한 하나의 필드를 가지고 있으며 해당 필드는 우리가 테스트해야 할 라벨과 도움말을 가지고 있음.

앞의 두 함수는 필드의 라벨과 도움말이 예상대로 생성되었는지를 확인함. 우리는 필드를 fields 딕셔너리를 통해서 접근했음. 라벨의 값이 None 인지도 확인해야하는 것을 기억해 두자. 장고가 올바른 라벨을 렌더하더라도 만약 라벨의 값이 명시적으로 정해지지 않았아뎜 None이 반환됨.
나머지 함수들은 폼이 적절한 구간 내에 있는 갱신 일자를 수락하는지와 더불어 부적합한 구간에 있는 일자를 거절하는지를 테스트 함. 우리가 테스트용 날짜들을 datetime.timedelta() 을 이용해서 현재 날짜 근처로 생성하는 것을 기억해두세요. 그리고나서 우리는 폼을 만들고, 데이터를 집어넣고, 데이터가 유효한지를 테스트함.
여기서 우리는 데이터베이스나 테스트 클라이언트를 사용하지 않음. simpletestcase를 이용해서 테스트클래스를 만드는 것을 고려해봐라. 또한 우리는 만약 폼이 유효하지 않을 경우, 적절한 에러가 발생하는지 역시 검증해야 함. 하지만 보통 이 부분은 view porcessing의 일부로 처리되기 때문에 다음 섹션에서 다루도록 하겠음.

이것이 form에 대한 전부임. 비록 다른 폼들이 있지만, 이들은 우리의 클래스 기반 편집 뷰에 의해 생성된 것들이기 때문에 그쪽에서 테스트 되어야 함. 테스트를 실행하고 우리의 코드가 여전히 테스트를 통과하는지 확인해 보자.

3. Views
우리의 뷰 동작을 유효하게 하기 위해서 우리는 Django test Client를 사용한다. 이 클래스는 더미 웹 브라우저와 같이 동작하는데, 우리는 URL의 GET 과 POST 요청을 동시에 하여 그 반응을 살핀다. 우리는 저수준의 HTTP 부터 HTML을 렌더하기 위한 탬플릿, 그리고 우리가 템플릿에 입력하는 컨텍스트 데이터까지 응답에 대한 거의 모든 것을 확인할 수 있음. 또한 우리는 redirect가 진행되는 단계와 각 단계에 대한 URL 및 상태 코드 역시 확인할 수 있음. 이를 통해서 우리는 각 뷰가 예상된 대로 동작하는 지를 확인할 수 있음.

우리의 가장간단한 뷰 중 하나인 모든 저자들의 목록을 반환하는 뷰부터 시작해보자.
이뷰가 generic list 뷰이다 보니 거의 모든 것이 장고에 의해서 처리된다. 만약 장고를 믿는다면 오로지 뷰가 올바른  URL과 뷰 이름으로 접근 가능한지만 테스트하면 됨. 하지만 만약 테스트 주도 방법론 를 따른다면 우리는 뷰가 모든 저자들을 10명씩 paginate해서 보여주는지를 확인하는 테스트부터 작성해야 함.

모든 테스트는 TestCase를 상속한 우리 테스트 클래스에 있는 클라이언트를 이용해서 Get 요청을 하고 그에 따른 응답을 받음. 첫번째 테스트는 특정 URL(도메인이 아닌 상대 경로임을 기억)을 확인하고 두번째 테스트는 URL 설정에서 설정해준 뷰의 이름에서 얻은 URL을 확인함.
응답을 받으면 우리는 응답에서 상태 코드, 사용된 템플릿, pagination이 되었는지 여부, 반환되니 객체의 갯수, 그리고 전체 아이템의 갯수를 확인함.
우리가 검증하는 변수 중 가장 흥미로운 변수는 바로 response.context로 뷰에 의해서 탬플릿에 전달되는 context 변수임. 이는 템플릿이 피룡한 모든 데이터를 받는지를 검증할 수 있게 해주기 때문에 테스팅에 정말 유용함. 즉 우리는 어떤 템플릿이 사용되고 또 어떤 데이터가 템플릿에 전달되는지를 확인할 수 있기 때문에 자신있게 렌더링에 관한 나머지 문제들은 오로지 템플릿의 문제라고 생각할 수 있음.

로그인한 사용자에게만 보이는 뷰
종종 우리는 로그인 한 사용자에게만 보이는 뷰를 테스트하고 싶음.
여기서 우리는 setup을 이용해서 계정을 생성한 다음 테스트에 사용할 bookinstance 객체와 관련된 책 밑 기타 정보를 생성함. 각각의 테스트 게정에 의해서 책이 반반씩 대출되었지만 일단 우리는 모든 책의 상태를 "maintenance"로 설정함. 우리는 테스트 하면서 이들 객체들을 수정할 것이기 때문에 SetupTestdata() 대신 setup을 사용햇음.
뷰가 로그인하지 않은 사용자를 로그인화면으로 redirect 하는 것을 확인하기 위해 우리는 assertRedriects를 사용함을 test_redirect_if_not_logged_in()에서 확인할 수 있음. 페이지가 로그인 한 사용자에게 보임을 확인하기 위해서 우린 테스트 유저로 로그인을 한 후에 페이지에 접근해서 응답의 상태코드가 200번임을 확인함.(성공을 의미)

'''
test하는 전체적인 과정을 처음접하게되었고, 내가생각했던것보다 web하나를 만드는데 엄청나게 많은 과정이 숨어있던것 같다.
다음과정은 배포하는 과정인데, 아직 배포까지는 생각할 겨를이안되어서.. 일단 다른 프로젝트로 넘어가서 계속 반복하여 Django에대한 이해를 늘려보도록 해볼것이다
ps.. 어렵당
'''